Na zÃ¡kladÄ› aktualizovanÃ©ho popisu problÃ©mu vidÃ­m, Å¾e se jednÃ¡ o kritickÃ½ problÃ©m v produkÄnÃ­m prostÅ™edÃ­ s duplicitnÃ­mi daty a nekonzistentnÃ­ synchronizacÃ­. Zde je pÅ™esnÃ¡ specifikace Å™eÅ¡enÃ­:

ğŸ¯ PÅ˜ESNÃ SPECIFIKACE Å˜EÅ ENÃ
1. KOMPLETNÃ PÅ˜EPSÃNÃ AuthContext.jsx
Asistent musÃ­ implementovat novou architekturu s tÄ›mito klÃ­ÄovÃ½mi komponentami:

// NOVÃ ARCHITEKTURA - 5 hlavnÃ­ch vrstev
// 1. CONNECTION LAYER - detekce online/offline
const [isOnline, setIsOnline] = useState(navigator.onLine);
const [lastOnlineTime, setLastOnlineTime] = useState(null);
// 2. QUEUE LAYER - atomickÃ½ queue management
const [syncQueue, setSyncQueue] = useState([]);
const [isSyncing, setIsSyncing] = useState(false);
const [syncStatus, setSyncStatus] = useState('idle');
// 3. CACHE LAYER - inteligentnÃ­ cache management
const [localCache, setLocalCache] = useState({});
const [cacheVersion, setCacheVersion] = useState(0);
// 4. SYNC LAYER - spolehlivÃ¡ synchronizace
const [syncErrors, setSyncErrors] = useState([]);
const [lastSyncTime, setLastSyncTime] = useState(null);
// 5. DATA LAYER - jedinÃ½ zdroj pravdy
const [dataState, setDataState] = useState('loading');
2. KRITICKÃ‰ FUNKCE K IMPLEMENTACI
A) InteligentnÃ­ addUserOrder
const addUserOrder = async (userId, orderData) => {
  // KROK 1: Vygeneruj unikÃ¡tnÃ­ doÄasnÃ© ID
  const tempId = `temp_${Date.now()}_${userId}_${Math.random().toString(36).substr(2, 9)}`;
  
  // KROK 2: VytvoÅ™ normalizovanou zakÃ¡zku
  const normalizedOrder = {
    ...orderData,
    id: tempId,
    user_id: userId,
    created_at: new Date().toISOString(),
    _isTemp: true,
    _queueId: tempId
  };
  
  // KROK 3: OkamÅ¾itÄ› aktualizuj UI (optimistic update)
  updateLocalCache(userId, normalizedOrder, 'add');
  
  // KROK 4: Zkus online uloÅ¾enÃ­
  if (isOnline) {
    try {
      const result = await saveToSupabaseAtomic(normalizedOrder);
      if (result.success) {
        // NahraÄ doÄasnÃ© ID skuteÄnÃ½m
        replaceTempIdInCache(userId, tempId, result.data);
        return result.data;
      }
    } catch (error) {
      console.warn('Online uloÅ¾enÃ­ selhalo:', error);
      setIsOnline(false);
    }
  }
  
  // KROK 5: PÅ™idej do queue pro pozdÄ›jÅ¡Ã­ synchronizaci
  addToSyncQueue('CREATE', normalizedOrder);
  
  return normalizedOrder;
};
B) AtomickÃ½ processQueue
const processQueue = async () => {
  if (isSyncing || !isOnline) return;
  
  setIsSyncing(true);
  setSyncStatus('syncing');
  
  const queue = [...syncQueue]; // Kopie pro atomickÃ© zpracovÃ¡nÃ­
  const processedItems = [];
  const failedItems = [];
  
  // Zpracuj kaÅ¾dou poloÅ¾ku atomicky
  for (const item of queue) {
    try {
      const result = await processQueueItemAtomic(item);
      if (result.success) {
        processedItems.push(item);
        // Aktualizuj cache s reÃ¡lnÃ½mi daty
        updateCacheWithRealData(item, result.data);
      } else {
        failedItems.push({ item, error: result.error });
      }
    } catch (error) {
      failedItems.push({ item, error });
      
      // Pokud je sÃ­Å¥ovÃ½ problÃ©m, pÅ™eruÅ¡ synchronizaci
      if (isNetworkError(error)) {
        setIsOnline(false);
        break;
      }
    }
  }
  
  // Atomicky odstraÅˆ ÃºspÄ›Å¡nÃ© poloÅ¾ky z queue
  setSyncQueue(prev => prev.filter(item => 
    !processedItems.find(processed => processed._queueId === item._queueId)
  ));
  
  // Zaloguj chyby
  if (failedItems.length > 0) {
    setSyncErrors(prev => [...prev, ...failedItems]);
  }
  
  setIsSyncing(false);
  setSyncStatus('idle');
  setLastSyncTime(new Date().toISOString());
};
C) InteligentnÃ­ getUserData
const getUserData = async (userId) => {
  // KROK 1: NaÄti cache
  const cacheData = getLocalCache(userId);
  
  if (!isOnline) {
    // Offline - vraÅ¥ pouze cache
    return cacheData;
  }
  
  try {
    // KROK 2: NaÄti data ze Supabase
    const { data: supabaseData, error } = await supabase
      .from('orders')
      .select('*')
      .eq('user_id', userId)
      .order('created_at', { ascending: false });
    
    if (error) throw error;
    
    // KROK 3: InteligentnÃ­ merge
    const mergedData = intelligentMerge(supabaseData, cacheData, userId);
    
    // KROK 4: Aktualizuj cache
    setLocalCache(prev => ({
      ...prev,
      [userId]: mergedData
    }));
    
    return mergedData;
    
  } catch (error) {
    console.warn('Supabase nedostupnÃ¡:', error);
    setIsOnline(false);
    return cacheData;
  }
};
3. KRITICKÃ‰ POMOCNÃ‰ FUNKCE
A) InteligentnÃ­ merge mechanismus
const intelligentMerge = (supabaseData, cacheData, userId) => {
  // Priorita: Supabase > doÄasnÃ© zÃ¡znamy z cache
  const merged = [...supabaseData];
  
  // PÅ™idej pouze doÄasnÃ© zÃ¡znamy, kterÃ© nejsou v Supabase
  const tempRecords = cacheData.filter(item => 
    item._isTemp && !merged.find(supabaseItem => 
      supabaseItem.klient === item.klient && 
      supabaseItem.castka === item.castka &&
      Math.abs(new Date(supabaseItem.created_at) - new Date(item.created_at)) < 5000
    )
  );
  
  return [...merged, ...tempRecords];
};
B) AtomickÃ© Supabase operace
const saveToSupabaseAtomic = async (orderData) => {
  try {
    const { data, error } = await supabase
      .from('orders')
      .insert([{
        ...orderData,
        id: undefined, // Nechej Supabase vygenerovat ID
        _isTemp: undefined,
        _queueId: undefined
      }])
      .select()
      .single();
    
    if (error) throw error;
    
    return { success: true, data };
  } catch (error) {
    return { success: false, error };
  }
};
C) SpolehlivÃ© ID replacement
const replaceTempIdInCache = (userId, tempId, realData) => {
  setLocalCache(prev => ({
    ...prev,
    [userId]: prev[userId].map(item =>
      item.id === tempId ? { ...realData, _isTemp: false } : item
    )
  }));
  
  // OdstraÅˆ z queue
  setSyncQueue(prev => prev.filter(item => item._queueId !== tempId));
};
4. SÃÅ¤OVÃ ODOLNOST
const isNetworkError = (error) => {
  return error.message.includes('fetch') || 
         error.message.includes('network') ||
         error.code === 'NETWORK_ERROR';
};
const handleNetworkError = () => {
  setIsOnline(false);
  // Restart queue processing za 30 sekund
  setTimeout(() => {
    if (navigator.onLine) {
      setIsOnline(true);
    }
  }, 30000);
};
5. VALIDACE A TESTOVÃNÃ
// Validace pÅ™ed uloÅ¾enÃ­m
const validateOrder = (orderData) => {
  const required = ['klient', 'castka', 'datum'];
  return required.every(field => orderData[field] !== undefined);
};
// Debug funkce pro produkci
const debugDataState = () => {
  console.log('=== DATA STATE DEBUG ===');
  console.log('Online:', isOnline);
  console.log('Queue length:', syncQueue.length);
  console.log('Cache keys:', Object.keys(localCache));
  console.log('Last sync:', lastSyncTime);
};
ğŸ“‹ IMPLEMENTAÄŒNÃ CHECKLIST
Asistent musÃ­ implementovat:
âœ… KompletnÄ› pÅ™epsat AuthContext.jsx - novÃ¡ architektura s 5 vrstvami
âœ… Implementovat inteligentnÃ­ merge - sprÃ¡vnÃ© kombinovÃ¡nÃ­ dat
âœ… AtomickÃ½ queue processing - buÄ ÃºspÄ›ch, nebo rollback
âœ… SpolehlivÃ© ID replacement - doÄasnÃ© â†’ skuteÄnÃ© ID
âœ… SÃ­Å¥ovÃ¡ odolnost - graceful handling chyb
âœ… Validace dat - ochrana pÅ™ed Å¡patnÃ½mi daty
âœ… Debug nÃ¡stroje - pro testovÃ¡nÃ­ v produkci
KritickÃ© aspekty:
Å½Ã¡dnÃ© duplicity - kaÅ¾dÃ¡ zakÃ¡zka existuje pouze jednou
AtomickÃ© operace - buÄ ÃºspÄ›ch, nebo rollback
JednoznaÄnÃ© ID - doÄasnÃ¡ ID se spolehlivÄ› nahrazujÃ­
KonzistentnÃ­ stav - cache vÅ¾dy odpovÃ­dÃ¡ Supabase
Tento nÃ¡vod poskytuje pÅ™esnou specifikaci pro eliminaci duplicit a zajiÅ¡tÄ›nÃ­ spolehlivÃ© synchronizace v produkÄnÃ­m prostÅ™edÃ­.